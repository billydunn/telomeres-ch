---
title: "Analysis of TERT promoter mutations in UK Biobank Whole Genomes"
author: "William Dunn"
date: "2025-01-09"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE) # Blanket suppress the code blocks globally for readability
```

## Data exploration and cleaning 

Here, we explore the data generated by performing pileup at each position along the *TERT* promoter. This is the data that was generated by Sruthi Cheloor Kovilakam by running Samtools mpileup across the *TERT* promoter on WGS data in the UK Biobank. 

```{r}
library(dplyr)
library(ggplot2)
library(ggbeeswarm)
library(scales)
library(ggforce)
library(gridExtra)
library(stats)
library(ggpubr)
library(VennDiagram)
library(MatchIt)
library(stringr)
library(corrplot)

# Read in the data 
tertp_df <- read.table("/Users/williamdunn/Desktop/PhD/Telomere_paper/TERTp_pileup/all_tert_snvs.tsv",
                       sep = "\t", header = TRUE)
```

We begin by exploring the dimensions of the table of all of these pileup calls:

```{r}
dim(tertp_df)
```

There are 4.68 million rows, that is, 4.68 million alternate allele calls (for 489,548 individuals - i.e. almost all individuals in the UKB). This means that across the region of interest (201bp long), each individual has on average 9-10 alternate allele calls - much too high to be true passenger/driver mutations, and already strongly suggestive of a lot of sequencing noise/error in the unfiltered calls. 

We next examine the range of depths to see if low depth regions have been filtered - here we survey the deciles of the depth across all positions:

```{r}
quantile(tertp_df$dp, probs = seq(0, 1, 0.1))
```

We can see that the depth across all position ranges from 2-242 reads, though most sites have 22-49 reads, and the median depth is 34 reads. 

Similarly, we can examine the deciles for the variant allele fraction (VAF): 

```{r}
quantile(tertp_df$vaf*100, probs = seq(0, 1, 0.1))
```

We can see that the median VAF is 3.1%, and that most alternate alleles are at low VAF (<6%), however, there are a few sites with very high VAF that might be more consistent with germline variants. 

We can visualise depth and VAF across the *TERT* promoter - here, we colour by whether or not the position is one of 3 sites that we propose to be driver mutations based on *a priori* knowledge of the positions of somatic rescue mutations in telomere biology disorders\textsuperscript{1} (chr5:1295046:T:G, chr5:1295113:G:A, and chr5:1295135:G:A): 

```{r}
# Visualise the number of reads at each position
tertp_pos_depth <- tertp_df %>% group_by(pos) %>% summarise(medianDepth=median(dp)) 

tertp_pos_depth$driver <- factor(
  ifelse(tertp_pos_depth$pos %in% c(1295046,1295113,1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

driver_colours <- c("Putative_driver" = "salmon", "Non_driver" = "lightblue")

# Visualise n variants by pileup per position
ggplot(data = tertp_pos_depth, aes(x = as.factor(pos), y = medianDepth, fill = driver)) +
  geom_bar(stat="identity") +
  scale_x_discrete(labels = function(x) {
    # Display label only for every fifth tick
    ifelse(as.numeric(tertp_pos_depth$pos) %% 5 == 0, x, "")
  }) +
  scale_y_continuous(labels = label_comma()) +
  scale_fill_manual(values = driver_colours) +
  ylab("Median depth by pileup across UKB") + xlab("Locus on chromosome 5") +
  theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4))

ggsave("plots/n_variants_vs_position_unfiltered.pdf")
```

```{r}
# Visualise the median VAF at each position
tertp_pos_vaf <- tertp_df %>% group_by(pos) %>% summarise(medianVAF=median(vaf)) 

tertp_pos_vaf$driver <- factor(
  ifelse(tertp_pos_vaf$pos %in% c(1295046,1295113,1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

driver_colours <- c("Putative_driver" = "salmon", "Non_driver" = "lightblue")

# Visualise vaf by pileup per position
ggplot(data = tertp_pos_vaf, aes(x = as.factor(pos), y = medianVAF, fill = driver)) +
  geom_bar(stat="identity") +
  scale_x_discrete(labels = function(x) {
    # Display label only for every fifth tick
    ifelse(as.numeric(tertp_pos_vaf$pos) %% 5 == 0, x, "")
  }) +
  scale_y_continuous(labels = label_comma()) +
  scale_fill_manual(values = driver_colours) +
  ylab("Median VAF by pileup across UKB") + xlab("Locus on chromosome 5") +
  theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4))

ggsave("plots/vaf_vs_position_unfiltered.pdf")
```

As expected, we see an inverse relationship between the median depth at each position and the median VAF of the alternate allele calls. We can more easily visualise this here by directly plotting median VAF vs median depth: 

```{r}
tertp_vaf_depth <- merge(tertp_pos_vaf, tertp_pos_depth, by = "pos")

ggplot(data = tertp_vaf_depth, aes(x = medianDepth, y = medianVAF)) + 
  geom_point() + 
  xlab("Median depth") + ylab("Median VAF") + 
  theme_bw()

ggsave("plots/vaf_vs_depth.pdf")
```

Finally, we can examine the number of variants at each position:

```{r}
# Visualise the number of reads at each position
tertp_pos_n_variants <- tertp_df %>% group_by(pos) %>% summarise(n=n()) 

tertp_pos_n_variants$driver <- factor(
  ifelse(tertp_pos_n_variants$pos %in% c(1295046,1295113,1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

# Visualise n variants by pileup per position
ggplot(data = tertp_pos_n_variants, aes(x = as.factor(pos), y = n, fill = driver)) +
  geom_bar(stat="identity") +
  scale_x_discrete(labels = function(x) {
    # Display label only for every fifth tick
    ifelse(as.numeric(tertp_pos_n_variants$pos) %% 5 == 0, x, "")
  }) +
  scale_y_continuous(labels = label_comma()) +
  scale_fill_manual(values = driver_colours) +
  ylab("Number of variants by pileup across UKB") + xlab("Locus on chromosome 5") +
  theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4))

ggsave("plots/vaf_vs_position_unfiltered.pdf")
```

We can see that at some positions, there are huge numbers of alternate allele calls (that is, at least 1 alternate allele detected) - with one site having almost 300,000 variant calls across the UKB. Our three sites of interest seem to have a relatively low number of alternate allele calls, although one of the sites 
(chr5:1295046) has a higher number, suggesting this site might be more prone to error than the others. 

We now start applying some fairly liberal arbitrary filters to the dataset to try and remove some of the noise and error and make the data more intelligible. We begin by applying a threshold of a minimum of 3 alternate reads, and also filtering sites with low depth (<15 reads) or a high VAF that might be suggestive of germline contamination (VAF >30%). Finally, where an individual has more than one different alternate allele call at the same position, we consider only the variant with the highest number of alternate alleles (e.g. if an individual has reads for both C>T and C>A at position X with 5 and 4 reads respectively, we retain the C>T call and discard the C>A call). What does this do to the number of alternate allele calls across the UKB?

```{r}
# Filter to exclude low depth and high vaf - I've arbitrarily chosen <15 reads and vaf 30%
tertp_df <- tertp_df[tertp_df$dp >= 15 & tertp_df$vaf < 0.3,]

min_reads <- 3 

# Group by individual, position; where an individual has >=2 different base alternate reads at each position, take the max read number 
deduplicated_tertp_df <- tertp_df %>%
  filter(alt_dp >= 3) %>%
  group_by(eid, pos) %>%
  arrange(desc(alt), .by_group = TRUE) %>% # Sort within groups by alt (descending)
  slice(1) %>%                             # Select the first row in each group
  ungroup()

dim(deduplicated_tertp_df)
```

We have now reduced the number of alternate allele calls from 4.68 million to 105,455. This is a substantial reduction - but it is still much higher than might be expected for real somatic mutations, suggesting that erroneous calls remain in the dataset. 

After applying these filters, how many variants are there at each position?

```{r}
table(deduplicated_tertp_df$pos)
```

We can see that there are some sites with only a single, or sometimes a handful of alternate allele calls (which could be true passengers), others with tens of thousands, suggestive of error, and some with total numbers in between, representing a grey area where it is more difficult to classify variants as driver, passenger or error.

Specifically, after applying these initial filters, how many variants are there amongst our three putative drivers, and what is the distribution of the alternate allele calls (the base changes are driver-specific: **chr5:1295046:T:G - NM_198253.3:c.-57A>C**, **chr5:1295113:G:A - NM_198253.3:c.-124C>T**, and **chr5:1295135:G:A  - NM_198253.3:c.-146C>T**).

```{r}
table(deduplicated_tertp_df$pos[deduplicated_tertp_df$pos %in% c(1295046,1295113,1295135)],
      deduplicated_tertp_df$alt[deduplicated_tertp_df$pos %in% c(1295046,1295113,1295135)])
```

At these sites, almost all the variants represent the expected driver mutation seen in telomere biology disorders. We can contrast this with the rest of the variants and try to visualise it with a stacked bar chart. Note: the y axis is on a log scale so that we can see the infrequently varying sites alongside the very frequently varying sites. This can be misleading as relatively modest differences in the proportions on log scale can reflect large differences on a linear scale.

Firstly, we examine the data before applying our filters (such as choosing the maximum at sites with more than one alternate allele call):

```{r}
tertp_pos_n_variants_unfiltered <- tertp_df %>%
  group_by(pos, alt) %>%  # Group by both position and alt
  summarise(n = n(), .groups = "drop") 

tertp_pos_n_variants_unfiltered$driver <- factor(
  ifelse(tertp_pos_n_variants_unfiltered$pos %in% c(1295046, 1295113, 1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

# Define colors for the alt values
alt_colours <- c("A" = "red", "C" = "blue", "T" = "green", "G" = "yellow")

ggplot(data = tertp_pos_n_variants_unfiltered, aes(x = as.factor(pos), y = log(n), fill = alt)) +
  geom_bar(stat = "identity") +  # Stacked bars
  scale_x_discrete(labels = function(x) {
    # Display label only for every fifth tick
    ifelse(as.numeric(x) %% 5 == 0, x, "")
  }) +
  scale_y_continuous(labels = label_comma()) +
  scale_fill_manual(values = alt_colours) +  # Apply custom colors for alt
  ylab("Log number of variants by pileup across UKB") +
  xlab("Locus on chromosome 5") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4))

ggsave("plots/n_variants_vs_alt_allele_unfiltered.pdf")
```

Next, we examine the data after filtering: 

```{r}
tertp_pos_n_variants_filtered <- deduplicated_tertp_df %>%
  group_by(pos, alt) %>%  # Group by both position and alt
  summarise(n = n(), .groups = "drop") 

tertp_pos_n_variants_filtered$driver <- factor(
  ifelse(tertp_pos_n_variants_filtered$pos %in% c(1295046, 1295113, 1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

# Define colors for the alt values
alt_colours <- c("A" = "red", "C" = "blue", "T" = "green", "G" = "yellow")

ggplot(data = tertp_pos_n_variants_filtered, aes(x = as.factor(pos), y = log(n), fill = alt)) +
  geom_bar(stat = "identity") +  # Stacked bars
  scale_x_discrete(labels = function(x) {
    # Display label only for every fifth tick
    ifelse(order(as.numeric(x)) %% 2 == 0, x, "")
  }) +
  scale_y_continuous(labels = label_comma()) +
  scale_fill_manual(values = alt_colours) +  # Apply custom colors for alt
  ylab("Log number of variants by pileup across UKB after initial filtering") +
  xlab("Locus on chromosome 5") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4))

ggsave("plots/n_variants_vs_alt_allele_filtered.pdf")

```

There are many sites where just a single alternate allele dominates after filtering by the minimum number of alternate reads and taking the alternative allele with the highest number of reads. 

We now focus on our three sites of interest and the proportion of alternate allele calls before and after filtering. Because the numbers are more comparable here, we now use a linear scale on the y axis.

Before filtering:

```{r}
tertp_pos_n_variants_filtered <- tertp_df %>%
  filter(pos %in% c(1295046,1295113,1295135)) %>%
  group_by(pos, alt) %>%  # Group by both position and alt
  summarise(n = n(), .groups = "drop") 

tertp_pos_n_variants_filtered$driver <- factor(
  ifelse(tertp_pos_n_variants_filtered$pos %in% c(1295046, 1295113, 1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

# Define colors for the alt values
alt_colours <- c("A" = "red", "C" = "blue", "T" = "green", "G" = "yellow")

ggplot(data = tertp_pos_n_variants_filtered, aes(x = as.factor(pos), y = n, fill = alt)) +
  geom_bar(stat = "identity") +  # Stacked bars
  scale_y_continuous(labels = label_comma()) +
  scale_fill_manual(values = alt_colours) +  # Apply custom colors for alt
  ylab("Number of variants by pileup across UKB") +
  xlab("Locus on chromosome 5") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4))

ggsave("plots/tertp_driver_positions_vs_alt_allele_unfiltered.pdf")
```

Note the very large number of calls before filtering. After filtering, the number of calls is substantially reduced:

```{r}
tertp_pos_n_variants_filtered <- deduplicated_tertp_df %>%
  filter(pos %in% c(1295046,1295113,1295135)) %>%
  group_by(pos, alt) %>%  # Group by both position and alt
  summarise(n = n(), .groups = "drop") 

tertp_pos_n_variants_filtered$driver <- factor(
  ifelse(tertp_pos_n_variants_filtered$pos %in% c(1295046, 1295113, 1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

# Define colors for the alt values
alt_colours <- c("A" = "red", "C" = "blue", "T" = "green", "G" = "yellow")

ggplot(data = tertp_pos_n_variants_filtered, aes(x = as.factor(pos), y = n, fill = alt)) +
  geom_bar(stat = "identity") +  # Stacked bars
  scale_y_continuous(labels = label_comma()) +
  scale_fill_manual(values = alt_colours) +  # Apply custom colors for alt
  ylab("Number of variants by pileup across UKB") +
  xlab("Locus on chromosome 5") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 4))

ggsave("plots/tertp_driver_positions_vs_alt_allele_filtered.pdf")
```

By applying our filters across the *TERT* promoter, we have enriched for what we believe to be "real" drivers at our sites of interest. It is worth noting again though, that at position chr5:1295046, unlike the other two positions, the "real" driver comprised the majority of alternate allele reads prior to filtering, so once again, we should pay special attention to this site, as it may be more likely than the other two positions to be contaminated by sequencing error.

Note that as a final filter at this stage, we have removed the two variants at our sites of interest that don't have the expected alternate allele.

```{r}
deduplicated_tertp_df <- deduplicated_tertp_df %>% filter(!(pos %in% c(1295113, 1295135) & alt != "A"))
```

We will now move on to examining the distribution of the number and VAF of reads at each position in our filtered dataset. As we saw earlier, there are lots of sites with only a handful of alternate reads after filtering; since we cannot discern a "distribution" with so few data points, I have arbitrarily excluded those sites with <= 10 variants for this visualisation step only. As there are a lot of data points, I have elected to make violin plots as visualising individual data points makes for unintelligible graphs due to over-plotting. Here, we examine the distribution of the number of alternate reads at each site (note that at sites where all variants have 3 alternate reads, there is no distribution to plot):

```{r, fig.width=8.27, fig.height=11.69}
deduplicated_tertp_df_plotting <- deduplicated_tertp_df %>% group_by(pos) %>% filter(n() >= 10) %>% ungroup()

deduplicated_tertp_df_plotting$driver <- factor(
  ifelse(deduplicated_tertp_df_plotting$pos %in% c(1295046,1295113,1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

locus_pos <- sort(unique(deduplicated_tertp_df_plotting$pos))

plots_list_n_violin = vector(mode="list", 
                      length = length(unique(deduplicated_tertp_df_plotting$pos)) %/% 10)

for (i in 1:length(plots_list_n_violin)){
  tmp_lower <- quantile(locus_pos, probs = seq(0, 1, 1/length(plots_list_n_violin)))[i]
  tmp_upper <- quantile(locus_pos, probs = seq(0, 1, 1/length(plots_list_n_violin)))[i+1]
  
  if (i == length(plots_list_n_violin)) {
    tmp_locus_pos <- locus_pos[locus_pos >= tmp_lower & 
                                 locus_pos <= tmp_upper]
  } else {
    tmp_locus_pos <- locus_pos[locus_pos >= tmp_lower & 
                                 locus_pos < tmp_upper]
  }
  
  tmp_df <- deduplicated_tertp_df_plotting[deduplicated_tertp_df_plotting$pos %in% tmp_locus_pos,]
  
  tick_colors <- setNames(ifelse(tmp_df$driver == "Putative_driver", "red", "black"), tmp_df$pos)
  
  plots_list_n_violin[[i]] <- ggplot(data = tmp_df,
                              aes(x = as.factor(pos),
                                  y = alt_dp, 
                                  fill = driver)) + 
    geom_violin() + 
    ylim(c(3,8)) + ylab("Alternate allele reads") +
    xlab("Position on Chromosome 5") +
    scale_fill_manual(values = driver_colours) +
    theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1,
                                                  color = tick_colors[levels(as.factor(tmp_df$pos))]))
  
}

invisible(pdf("plots/violin_plots_n_reads_vs_position.pdf", width=14, height=8, onefile = FALSE))
do.call(grid.arrange, c(plots_list_n_violin, ncol = 1))
invisible(dev.off())

do.call(grid.arrange, c(plots_list_n_violin, ncol = 1))
```

We can see that the distribution of the number of alternate reads is distinctly different at our three sites of interest, consistent with this being "real" and the other sites being largely sequencing noise. Of note, the distribution of the number of alternate reads at chr5:1295034 is very similar to our sites of interest, suggesting that this position might also be worth considering as a putative driver. 

What are the alternate alleles at chr5:1295034?

```{r}
table(deduplicated_tertp_df_plotting$pos[deduplicated_tertp_df_plotting$pos == 1295034],
      deduplicated_tertp_df_plotting$alt[deduplicated_tertp_df_plotting$pos == 1295034])
```

They are all C>A mutations, and there are 12 individuals with these mutations.

We can also visualise the differences between distributions of alternate allele reads more formally by using the Mann-Whitney U test, computing n by n comparisons, then plotting the -log10 of the adjusted p values for these n by n comparisons in a heatmap. Since the computed p value is in part a function of sample size, we take a random sample of n=100 from sites where there are >100 variants passing filters (otherwise, at noisy sites with e.g. 10,000 variants passing our liberal filters, these have very large p values driven largely by their sample size). We see that our three sites of interest have the largest p values, in addition to the fourth site that we speculate may be an unreported driver:

```{r, fig.width=8.27, fig.height=11.69}
# Randomly subsample the tertp calls so that the sample size for the noisy sites is max 100 
subsampled_df_n <- deduplicated_tertp_df_plotting %>%
  group_by(pos) %>%                   # Group by the `pos` variable
  slice_sample(n = 100, replace = FALSE) %>%  # Randomly sample 100 rows per group (or fewer if less exist)
  ungroup() 

n_by_n <- pairwise.wilcox.test(subsampled_df_n$alt_dp, 
                                   as.factor(subsampled_df_n$pos),
                                   p.adjust.method = "fdr")

pvals_n <- as.matrix(n_by_n$p.value)
pvals_n[pvals_n == 0] <- 0.000000000001
pvals_n <- -log10(pvals_n)

invisible(pdf("plots/neg_log_p_val_pairwise_comparison_n_alt_alleles.pdf", width=14, height=8, onefile = FALSE))
corrplot(pvals_n, is.corr = FALSE, type = "lower", na.label = " ")
invisible(dev.off())

corrplot(pvals_n, is.corr = FALSE, type = "lower", na.label = " ")
```

We can also visualise the distribution of VAFs across sites:

```{r, fig.width=8.27, fig.height=11.69}
plots_list_vaf_violin = vector(mode="list", 
                      length = length(unique(deduplicated_tertp_df_plotting$pos)) %/% 10)

for (i in 1:length(plots_list_vaf_violin)){
  tmp_lower <- quantile(locus_pos, probs = seq(0, 1, 1/length(plots_list_vaf_violin)))[i]
  tmp_upper <- quantile(locus_pos, probs = seq(0, 1, 1/length(plots_list_vaf_violin)))[i+1]
  
  if (i == length(plots_list_vaf_violin)) {
    tmp_locus_pos <- locus_pos[locus_pos >= tmp_lower & 
                                 locus_pos <= tmp_upper]
  } else {
    tmp_locus_pos <- locus_pos[locus_pos >= tmp_lower & 
                                 locus_pos < tmp_upper]
  }
  
  tmp_df <- deduplicated_tertp_df_plotting[deduplicated_tertp_df_plotting$pos %in% tmp_locus_pos,]
  
  tick_colors <- setNames(ifelse(tmp_df$driver == "Putative_driver", "red", "black"), tmp_df$pos)
  
  plots_list_vaf_violin[[i]] <- ggplot(data = tmp_df,
                              aes(x = as.factor(pos),
                                  y = vaf, 
                                  fill = driver)) + 
    geom_violin() +
    ylim(c(0,0.3)) +
    ylab("VAF") +
    xlab("Position on Chromosome 5") +
    scale_fill_manual(values = driver_colours) +
    theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1,
                                                  color = tick_colors[levels(as.factor(tmp_df$pos))]))
  
}

invisible(pdf("plots/violin_plots_vaf_vs_position.pdf", width=14, height=8, onefile = FALSE))
do.call(grid.arrange, c(plots_list_vaf_violin, ncol = 1))
invisible(dev.off())

do.call(grid.arrange, c(plots_list_vaf_violin, ncol = 1))
```

Again, we see that the distribution of VAFs are our site of interest looks distinct from the rest, and once again, the additional position of chr5:1295034 looks to have a distribution of VAFs that bears resemblance to our putative driver sites. 

## Association with polygenic risk score for leukocyte telomere length

When we visualise the distribution of polygenic risk scores at each position on the *TERT* promoter, our three sites of interest seem to have lower PRS. Of note, the previously discussed site chr5:1295034 once again shows a similar trend (though it is worth stressing there are only 12 individuals with mutations passing filters at this site): 

```{r}
prs <- read.table("/Users/williamdunn/Desktop/PhD/Papers/UKB_blood_counts/dat/telomere_PRS_all.tsv",
               header = TRUE, sep = "\t")

prs$z_norm_prs <- scale(prs$total_PRS)

prs_plotting_df <- merge(deduplicated_tertp_df_plotting, prs, by = "eid")

ggplot(data = prs_plotting_df, aes(x = as.factor(pos), y = z_norm_prs, fill = driver)) + 
  scale_fill_manual(values = driver_colours) + geom_boxplot() + theme_bw() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ylab("PRS") +
    xlab("Position on Chromosome 5")
ggsave("plots/PRS_vs_position_filtered.pdf")
```

We can also make a pairwise comparison of the PRS of individuals with putative *TERT*p driver mutations with the rest of the UKB:

```{r}
# Update the driver calls - if private, call passenger, otherwise NA
passengers <- deduplicated_tertp_df %>% group_by(pos) %>% summarise(n=n()) %>% 
  slice_min(n) %>% pull(pos)

deduplicated_tertp_df$driver_passenger <- case_when(
  deduplicated_tertp_df$pos %in% passengers ~ "Passenger",
  deduplicated_tertp_df$pos %in% c(1295046,1295113,1295135) ~ "Driver",
                                                    TRUE ~ NA)

prs$driver <- ifelse(
  prs$eid %in% deduplicated_tertp_df$eid[
  deduplicated_tertp_df$driver_passenger == "Driver" & !is.na(deduplicated_tertp_df$driver_passenger)],
  1,
  0
)

ggplot(data = prs, aes(x = as.factor(driver), y = z_norm_prs, 
                       fill = as.factor(driver))) + geom_boxplot() +
  stat_compare_means(label = "p.format") + theme_bw() + 
  ylab("Z-normalised telomere PRS") + xlab("TERTp") + scale_x_discrete(
    breaks = c(0, 1),
    labels = c("WT", "MUT")
  ) + theme(legend.position = "none")

ggsave("plots/prs_UKB_vs_tertp_drivers.pdf")
```


## Age-related prevalence of *TERT*p putative drivers versus splicing mutations 

We can also compare the prevalence of the *TERT*p driver mutations we have identified here with the prevalence of splicing factor mutations called from WGS data (using the thresholds and filters specified here), and contrast this with splicing factor, *DNMT3A* and *JAK2* mutations called from WES data using a more conventional Mutect2-based approach. Here, we are only comparing the combined prevalence of the *SF3B1* (R625, K666 and K700) and *SRSF2* (P95) hotspot mutations that we called using pileup, so that we are comparing like with like:

```{r}
ukb <- readRDS("/Users/williamdunn/Desktop/PhD/Gagarin_data/UKBB/Danish_validation/dat/master_file_hes_bloodcounts_validation.rds")

# Load in the SF3B1/SRSF2 hotspot WGS pileup data 
splicing_wgs <- read.table("/Users/williamdunn/Desktop/PhD/Telomere_paper/TERTp_pileup/dat/pileup_summary.txt", header = FALSE)

colnames(splicing_wgs) <- c("eid","CHROM", "POS", "REF", "ALT", "DP", "ALT_DP", "VAF")

splicing_wgs$eid <- as.integer(substr(splicing_wgs$eid, 1, 7))

# Filter the splicing wgs using the same criteria as we used for the TERTp locus

splicing_wgs_filtered <- splicing_wgs[splicing_wgs$DP >= 15 & splicing_wgs$VAF< 0.3,]

# Group by individual, position; where an individual has >=2 different base alternate reads at each position, take the max read number 
splicing_wgs_filtered <- splicing_wgs_filtered %>%
  filter(ALT_DP >= 3) %>%
  group_by(eid, POS) %>%
  arrange(desc(ALT), .by_group = TRUE) %>% # Sort within groups by alt (descending)
  slice(1) %>%                             # Select the first row in each group
  ungroup()

# Only include the individual with 2 (SF3B1 + SRSF2) mutations once
splicing_wgs_filtered <- splicing_wgs_filtered[!duplicated(splicing_wgs_filtered$eid),]

# Load in the WES Mutect2 calls from Sruthi's DDX41 paper; combine with the list of EIDs with WES to allow ascertainment of prevalence 
wes <- read.table("/Users/williamdunn/Desktop/PhD/Papers/UKB_blood_counts/dat/ids-geno-vaf-natgen.txt", header = TRUE)
sruthi_calls <- read.table("dat/results_var_ch_all_allgenes_UKB", header = TRUE)

sruthi_SF3B1 <- sruthi_calls %>% filter(symbol == "SF3B1" &
                                          (str_detect(p_mut, "R625") |
                                             str_detect(p_mut, "K666") |
                                             str_detect(p_mut, "K700")) 
                                        ) %>% pull(eid)
sruthi_SRSF2 <- sruthi_calls %>% filter(symbol == "SRSF2" & str_detect(p_mut, "P95")) %>% pull(eid)
sruthi_JAK2 <- sruthi_calls %>% filter(symbol == "JAK2" & str_detect(p_mut, "V617F")) %>% pull(eid)
sruthi_DNMT3A_R882 <- sruthi_calls %>% filter(symbol == "DNMT3A" & str_detect(p_mut, "R882")) %>% pull(eid)

wes$sruthi_SF3B1 <- ifelse(wes$row %in% sruthi_SF3B1,
                              1,
                              0)
wes$sruthi_SRSF2 <- ifelse(wes$row %in% sruthi_SRSF2,
                              1,
                              0)
wes$sruthi_JAK2 <- ifelse(wes$row %in% sruthi_JAK2,
                              1,
                              0)
wes$sruthi_DNMT3A_R882 <- ifelse(wes$row %in% sruthi_DNMT3A_R882,
                              1,
                              0)


ages <- ukb[,colnames(ukb) %in% c("eid", "Age_at_recruitment", "prevalent_case")]

wes <- merge(ages, 
             wes,
             by.x = "eid",
             by.y = "row") 

# Exclude prevalent MN cases 
wes <- wes[wes$prevalent_case != 1,]

n_bins <- 15

prevalence_wgs_vs_wes <- expand.grid(age = levels(cut(seq(40, 70, 1),n_bins)),
                                     prevalence = NA,
                                     driver = c("TERTp_WGS","SF3B1_SRSF2_WGS", "SF3B1_SRSF2_WES", "JAK2_WES",
                                                "DNMT3A_R882_WES"))

wgs_age_splice_status <- data.frame(eid = unique(tertp_df$eid),
                                    splice = 0,
                                    TERTp = 0)
wgs_age_splice_status <- merge(wgs_age_splice_status, ages, by = "eid")
wgs_age_splice_status$splice[wgs_age_splice_status$eid %in% splicing_wgs_filtered$eid] <- 1
wgs_age_splice_status$TERTp[wgs_age_splice_status$eid %in% 
                              deduplicated_tertp_df$eid[deduplicated_tertp_df$driver_passenger == "Driver"
                                                        & !is.na(deduplicated_tertp_df$driver_passenger)]] <- 1

# Exclude prevalent MN cases from wgs data too 
wgs_age_splice_status <- wgs_age_splice_status[wgs_age_splice_status$eid %in% ukb$eid[ukb$prevalent_case == 0],]

# Need to split splicing up and add tertp df 

for (i in 1:length(levels(prevalence_wgs_vs_wes$age))) {
  tmp_age <- levels(prevalence_wgs_vs_wes$age)[i]
  
  # Extract the lower bound
  lower_bound <- as.numeric(sub("\\((\\d+),.*", "\\1", tmp_age))
  
  # Extract the upper bound
  upper_bound <- as.numeric(sub(".*,(\\d+)]", "\\1", tmp_age))
  
  tmp_wes <- wes[wes$Age_at_recruitment > lower_bound & wes$Age_at_recruitment <= upper_bound,]
  tmp_splice_wgs <- wgs_age_splice_status[wgs_age_splice_status$Age_at_recruitment > lower_bound & wgs_age_splice_status$Age_at_recruitment <= upper_bound,] 
  
  tmp_n_wes <- nrow(tmp_wes)
  tmp_n_wgs <- nrow(tmp_splice_wgs)

  tmp_n_tertp_driver <- sum(tmp_splice_wgs$TERTp) # Unique ID as interested in individuals not variants
  tmp_prev_tertp_driver <- (tmp_n_tertp_driver / tmp_n_wgs) * 100 # Total number of individuals
  
  tmp_n_splice_wgs <- sum(tmp_splice_wgs$splice)
  tmp_prev_splice_wgs <- (tmp_n_splice_wgs / tmp_n_wgs) * 100 # Total number of individuals
  
  tmp_n_splice_wes <- length(unique(tmp_wes$eid[tmp_wes$sruthi_SF3B1 != 0 | tmp_wes$sruthi_SRSF2 != 0])) # Unique ID as interested in individuals not variants
  tmp_prev_splice_wes <- (tmp_n_splice_wes / tmp_n_wes) * 100 # Total number of individuals
  
  tmp_n_jak2 <- length(unique(tmp_wes$eid[tmp_wes$sruthi_JAK2 != 0])) # Unique ID as interested in individuals not variants
  tmp_prev_jak2 <- (tmp_n_jak2 / tmp_n_wes) * 100 # Total number of individuals
  
  tmp_n_dnmt3a_r882 <- length(unique(tmp_wes$eid[tmp_wes$sruthi_DNMT3A_R882 != 0])) # Unique ID as interested in individuals not variants
  tmp_prev_dnmt3a_r882 <- (tmp_n_dnmt3a_r882 / tmp_n_wes) * 100 # Total number of individuals
  
  prevalence_wgs_vs_wes$prevalence[prevalence_wgs_vs_wes$age == tmp_age] <- c(tmp_prev_tertp_driver,
                                                                              tmp_prev_splice_wgs,
                                                                              tmp_prev_splice_wes,
                                                                              tmp_prev_jak2,
                                                                              tmp_prev_dnmt3a_r882)
}

ggplot(data = prevalence_wgs_vs_wes, aes(x = as.numeric(age), y = prevalence, colour = driver)) + 
  ylab("Prevalence (%)") + xlab("Age (years)") +
  scale_x_continuous(breaks = as.numeric(unique(prevalence_wgs_vs_wes$age)),
                     labels = sub("\\((\\d+),.*", "\\1", unique(prevalence_wgs_vs_wes$age))) +
  geom_smooth(se = FALSE) + theme_bw() 

ggsave("plots/tertp_prevalence_vs_splicing_combined.pdf")
```

We can also reproduce the plot but distinguishing between *SRSF2* and *SF3B1*:

```{r}
prevalence_wgs_vs_wes <- expand.grid(age = levels(cut(seq(40, 70, 1),n_bins)),
                                     prevalence = NA,
                                     driver = c("TERTp_WGS",
                                                "SF3B1_WGS", "SF3B1_WES", 
                                                "SRSF2_WGS", "SRSF2_WES", 
                                                "JAK2_WES",
                                                "DNMT3A_R882_WES"))

wgs_age_splice_status <- data.frame(eid = unique(tertp_df$eid),
                                    SF3B1 = 0,
                                    SRSF2 = 0,
                                    TERTp = 0)
wgs_age_splice_status <- merge(wgs_age_splice_status, ages, by = "eid")
wgs_age_splice_status$SF3B1[wgs_age_splice_status$eid %in% 
                              splicing_wgs_filtered$eid[splicing_wgs_filtered$CHROM == "chr2"]] <- 1
wgs_age_splice_status$SRSF2[wgs_age_splice_status$eid %in% 
                              splicing_wgs_filtered$eid[splicing_wgs_filtered$CHROM == "chr17"]] <- 1
wgs_age_splice_status$TERTp[wgs_age_splice_status$eid %in% 
                              deduplicated_tertp_df$eid[deduplicated_tertp_df$driver_passenger == "Driver"
                                                        & !is.na(deduplicated_tertp_df$driver_passenger)]] <- 1

# Exclude prevalent cases from wgs data too 
wgs_age_splice_status <- wgs_age_splice_status[wgs_age_splice_status$eid %in% ukb$eid[ukb$prevalent_case == 0],]

for (i in 1:length(levels(prevalence_wgs_vs_wes$age))) {
  tmp_age <- levels(prevalence_wgs_vs_wes$age)[i]
  
  # Extract the lower bound
  lower_bound <- as.numeric(sub("\\((\\d+),.*", "\\1", tmp_age))
  
  # Extract the upper bound
  upper_bound <- as.numeric(sub(".*,(\\d+)]", "\\1", tmp_age))
  
  tmp_wes <- wes[wes$Age_at_recruitment > lower_bound & wes$Age_at_recruitment <= upper_bound,]
  tmp_splice_wgs <- wgs_age_splice_status[wgs_age_splice_status$Age_at_recruitment > lower_bound & wgs_age_splice_status$Age_at_recruitment <= upper_bound,] 
  
  tmp_n_wes <- nrow(tmp_wes)
  tmp_n_wgs <- nrow(tmp_splice_wgs)

  tmp_n_tertp_driver <- sum(tmp_splice_wgs$TERTp) # Unique ID as interested in individuals not variants
  tmp_prev_tertp_driver <- (tmp_n_tertp_driver / tmp_n_wgs) * 100 # Total number of individuals
  
  tmp_n_SF3B1_wgs <- sum(tmp_splice_wgs$SF3B1)
  tmp_prev_SF3B1_wgs <- (tmp_n_SF3B1_wgs / tmp_n_wgs) * 100 # Total number of individuals
  
  tmp_n_SRSF2_wgs <- sum(tmp_splice_wgs$SRSF2)
  tmp_prev_SRSF2_wgs <- (tmp_n_SRSF2_wgs / tmp_n_wgs) * 100 # Total number of individuals
  
  tmp_n_SF3B1_wes <- length(unique(tmp_wes$eid[tmp_wes$sruthi_SF3B1 != 0])) # Unique ID as interested in individuals not variants
  tmp_prev_SF3B1_wes <- (tmp_n_SF3B1_wes / tmp_n_wes) * 100 # Total number of individuals
  
  tmp_n_SRSF2_wes <- length(unique(tmp_wes$eid[tmp_wes$sruthi_SRSF2 != 0])) # Unique ID as interested in individuals not variants
  tmp_prev_SRSF2_wes <- (tmp_n_SRSF2_wes / tmp_n_wes) * 100 # Total number of individuals
  
  tmp_n_jak2 <- length(unique(tmp_wes$eid[tmp_wes$sruthi_JAK2 != 0])) # Unique ID as interested in individuals not variants
  tmp_prev_jak2 <- (tmp_n_jak2 / tmp_n_wes) * 100 # Total number of individuals
  
  tmp_n_dnmt3a_r882 <- length(unique(tmp_wes$eid[tmp_wes$sruthi_DNMT3A_R882 != 0])) # Unique ID as interested in individuals not variants
  tmp_prev_dnmt3a_r882 <- (tmp_n_dnmt3a_r882 / tmp_n_wes) * 100 # Total number of individuals
  
  prevalence_wgs_vs_wes$prevalence[prevalence_wgs_vs_wes$age == tmp_age] <- c(tmp_prev_tertp_driver,
                                                                              tmp_prev_SF3B1_wgs,
                                                                              tmp_prev_SF3B1_wes,
                                                                              tmp_prev_SRSF2_wgs,
                                                                              tmp_prev_SRSF2_wes,
                                                                              tmp_prev_jak2,
                                                                              tmp_prev_dnmt3a_r882)
}

ggplot(data = prevalence_wgs_vs_wes, aes(x = as.numeric(age), y = prevalence, colour = driver)) + 
  ylab("Prevalence (%)") + xlab("Age (years)") +
  scale_x_continuous(breaks = as.numeric(unique(prevalence_wgs_vs_wes$age)),
                     labels = sub("\\((\\d+),.*", "\\1", unique(prevalence_wgs_vs_wes$age))) +
  scale_colour_manual(values = c("TERTp_WGS" = "red",
                                 "SF3B1_WGS" = "lightgreen", 
                                 "SF3B1_WES" = "green", 
                                 "SRSF2_WGS" = "cyan", 
                                 "SRSF2_WES" = "blue", 
                                 "JAK2_WES" = "orange",
                                 "DNMT3A_R882_WES" = "purple")) +
  geom_smooth(se = FALSE) + theme_bw() 

ggsave("plots/tertp_prevalence_vs_SF3B1_SRSF2.pdf")
```

For clarity, we can also re-plot this removing the comparison with *DNMT3A* and *JAK2* hotspot mutation prevalence and colouring in different shades of green/blue for *SF3B1*/*SRSF2* respectively:

```{r}
ggplot(data = prevalence_wgs_vs_wes[!prevalence_wgs_vs_wes$driver %in% c("JAK2_WES",
                                                                         "DNMT3A_R882_WES"),], 
       aes(x = as.numeric(age), y = prevalence, colour = driver)) + 
  ylab("Prevalence (%)") + xlab("Age (years)") +
  scale_x_continuous(breaks = as.numeric(unique(prevalence_wgs_vs_wes$age)),
                     labels = sub("\\((\\d+),.*", "\\1", unique(prevalence_wgs_vs_wes$age))) +
  scale_colour_manual(values = c("TERTp_WGS" = "red",
                                 "SF3B1_WGS" = "lightgreen", 
                                 "SF3B1_WES" = "darkgreen", 
                                 "SRSF2_WGS" = "cyan", 
                                 "SRSF2_WES" = "blue")) +
  geom_smooth(se = FALSE) + theme_bw() 

ggsave("plots/tertp_prevalence_vs_SF3B1_SRSF2_clearer.pdf")
```

These plots show that, when we apply the same methodology to call splicing and *TERT*p hotspot mutations from WGS data, the prevalence of *TERT*p mutations appears similar to the combined prevalence of CH driven by *SF3B1* and *SRSF2* mutations.  

To benchmark our ability to call hotspot mutations from WGS using the liberal filtering method described here, we can compare the overlap between *SF3B1*/*SRSF2* called using our described filtering of WGS pileup, versus calling this using Mutect2 on WES (note here that we are using the subset of UKB participants who have both WES and WGS, as ~490k have WGS c.f. only ~450k have WES).

```{r, fig.width=6}
wgs_sf3b1_ids <- as.character(unique(splicing_wgs_filtered$eid[splicing_wgs_filtered$CHROM == "chr2"]))
wes_sf3b1_ids <- as.character(wes$eid[wes$sruthi_SF3B1 != 0])

wgs_srsf2_ids <- as.character(unique(splicing_wgs_filtered$eid[splicing_wgs_filtered$CHROM == "chr17"]))
wes_srsf2_ids <- as.character(wes$eid[wes$sruthi_SRSF2 != 0])

# Further subset the WGS to only include individuals who have WES, otherwise it is a misleading comparison
wgs_sf3b1_ids <- wgs_sf3b1_ids[wgs_sf3b1_ids %in% as.character(wes$eid)]
wgs_srsf2_ids <- wgs_srsf2_ids[wgs_srsf2_ids %in% as.character(wes$eid)]

venn.plot.sf3b1 <- venn.diagram(
  x = list(
    WGS = wgs_sf3b1_ids,
    WES = wes_sf3b1_ids
  ),
  width = 2000,
  height = 2000,
  filename = NULL, # Retain in memory/do not save to file 
  fill = c("blue", "red"), 
  alpha = 0.5, 
  cat.col = c("black", "black"), # Label colour
  cat.cex = 1.5, # Label font size
  cat.pos = c(-10,10),
  cat.default.pos = "text",
  main = "Overlap of SF3B1 calls between WGS (pileup) and WES (Mutect2)"
)

venn.plot.srsf2 <- venn.diagram(
  x = list(
    WGS = wgs_srsf2_ids,
    WES = wes_srsf2_ids
  ),
  filename = NULL, # Retain in memory/do not save to file 
  fill = c("blue", "red"), 
  alpha = 0.5, 
  cat.col = c("black", "black"), # Label colour
  cat.cex = 1.5, # Label font size
  cat.pos = c(-10,10),
  cat.default.pos = "text",
  main = "Overlap of SRSF2 calls between WGS (pileup) and WES (Mutect2)"
)

invisible(pdf("plots/venn_sf3b1.pdf", width=14, height=8, onefile = FALSE))
grid::grid.draw(venn.plot.sf3b1)
invisible(dev.off())

grid::grid.draw(venn.plot.sf3b1)
```

```{r, fig.width=6}
invisible(pdf("plots/venn_srsf2.pdf", width=14, height=8, onefile = FALSE))
grid::grid.draw(venn.plot.srsf2)
invisible(dev.off())

grid::grid.draw(venn.plot.srsf2)
```

We see that there are a number of mutations that are *only* detected by pileup on WGS, despite the lower depth of WGS. To examine whether or not these appear to be "real" calls (versus error), we next examine whether these WGS-exclusive calls associate with macrocytosis (*SF3B1*) and thrombocytopenia (*SRSF2*) (that is, do they exhibit known blood count phenotypes associated with these mutations). The reference (leftmost) group in both cases is a cohort of age and sex matched controls where the sample size is ten-fold greater than the number of *SF3B1*/*SRSF2* cases respectively:

```{r}
ukb$SF3B1_by_WGS_only <- ifelse(as.character(ukb$eid) %in% wgs_sf3b1_ids & 
                                  !ukb$eid %in% wes$eid[wes$SF3B1 == 0],
                                1, 0)
ukb$SRSF2_by_WGS_only <- ifelse(as.character(ukb$eid) %in% wgs_srsf2_ids & 
                                  !ukb$eid %in% wes$eid[wes$SRSF2 == 0],
                                1, 0)

set.seed(1872)

matchit_SF3B1 <- matchit(
  SF3B1_by_WGS_only ~ Age_at_recruitment + Sex,
  data = ukb[!is.na(ukb$Age_at_recruitment),],
  method = "nearest",
  ratio = 10
)

matched_SF3B1 <- match.data(matchit_SF3B1)

matchit_SRSF2 <- matchit(
  SRSF2_by_WGS_only ~ Age_at_recruitment + Sex,
  data = ukb[!is.na(ukb$Age_at_recruitment),],
  method = "nearest",
  ratio = 10
)

matched_SRSF2 <- match.data(matchit_SRSF2)
```

We can see that our pileup calls for *SF3B1* have a higher MCV than an age- and sex-matched cohort:

```{r}
ggplot(data = matched_SF3B1, aes(x = as.factor(SF3B1_by_WGS_only),
                                 y = `Mean corpuscular volume`,
                                 fill = as.factor(SF3B1_by_WGS_only))) + geom_boxplot() +
  xlab("SF3B1") +
  theme_bw() + stat_compare_means(label = "p.format") + 
  scale_x_discrete(
    breaks = c(0, 1),
    labels = c("WT", "MUT")
  ) + theme(legend.position = "none")

ggsave("plots/SF3B1_pileup_only_MCV.pdf")
```

And our *SRSF2* calls by pileup have lower platelet counts:

```{r}
ggplot(data = matched_SRSF2, aes(x = as.factor(SRSF2_by_WGS_only),
                                 y = `Platelet count`,
                                 fill = as.factor(SRSF2_by_WGS_only))) + geom_boxplot() +
  xlab("SRSF2") +
  theme_bw() + stat_compare_means(label = "p.format") + scale_x_discrete(
    breaks = c(0, 1),
    labels = c("WT", "MUT")
  ) + theme(legend.position = "none")

ggsave("plots/SRSF2_pileup_only_platelets.pdf")
```

## Association between TERTp variants and lymphocyte count 

We wanted to ensure that individuals with *TERT*p mutations did not have a higher relative lymphocyte count (relative to granulocytes), since this might suggest that these mutations were present in a lymphoid progenitor, rather than a HSC or myeloid progenitor.

Firstly, we plot the absolute lymphocyte count vs position on the *TERT* promoter, to check whether or not these individuals have a phenotype suggestive of unannotated CLL or MBL:

```{r}
cbc_plotting_df <- merge(deduplicated_tertp_df_plotting, ukb, by = "eid")

cbc_plotting_df$driver <- factor(
  ifelse(cbc_plotting_df$pos %in% c(1295046,1295113,1295135),
         "Putative_driver",
         "Non_driver"), 
  levels = c("Non_driver", "Putative_driver"))

ggplot(data = cbc_plotting_df, aes(x = as.factor(pos), y = `Lymphocyte count`, fill = driver)) + 
  scale_fill_manual(values = driver_colours) + geom_boxplot() + theme_bw() + ylim(c(0,5)) + 
  xlab("Position on Chromosome 5") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("plots/lymphocyte_count_vs_position.pdf")
```

Here, we don't see any strong association between the absolute lymphocyte count and the presence of these putative *TERT*p driver mutations. 

We can also look at the VAF and colour by the lymphocyte percentage to examine whether those with a high VAF have a high lymphocyte percentage (consistent with the *TERT*p mutations being present in a lymphocyte progenitor):

```{r}
ggplot(data = cbc_plotting_df[cbc_plotting_df$pos %in% c(1295046, 1295113, 1295135),],
       aes(x = as.factor(pos), y = vaf, colour = `Lymphocyte count` / `White blood cell (leukocyte) count`)) + 
  geom_beeswarm() + theme_bw() + scale_colour_gradient(low = "blue", high = "red") +
  ylab("TERTp mtuation VAF") + xlab("Position on Chromosome 5")

ggsave("plots/lymphocyte_pct_vs_TERTp_vaf_beeswarm.pdf")
```

Alternatively, we can directly plot VAF vs lymphocyte percentage across the three sites:

```{r}
ggplot(data = cbc_plotting_df[cbc_plotting_df$pos %in% c(1295046, 1295113, 1295135),],
       aes(x = vaf, y = `Lymphocyte count` / `White blood cell (leukocyte) count`)) + 
  geom_point() + geom_smooth() + theme_bw() +
  xlab("TERTp mutation VAF") + ylab("Lymphocyte percentage")

ggsave("plots/lymphocyte_pct_vs_TERTp_vaf_scatter.pdf")
```

We can see that there is no apparent association between TERTp mutation VAF and lymphocyte percentage, and therefore no evidence to suggest that these mutations are present in a lymphoid population.

```{r}
# Save the TERTp variant calls to file; include the whole "dirty" filtered calls
# This way we can easily revisit the ?4th hotspot in future 
saveRDS(deduplicated_tertp_df, file = "dat/tertp_variants_passing_filters.rds")
```

## References

1. Gutierrez-Rodrigues F, Groarke EM, Thongon N, Rodriguez-Sevilla JJ, Catto LFB, Niewisch MR, Shalhoub R, McReynolds LJ, Clé DV, Patel BA, Ma X, Hironaka D, Donaires FS, Spitofsky N, Santana BA, Lai TP, Alemu L, Kajigaya S, Darden I, Zhou W, Browne PV, Paul S, Lack J, Young DJ, DiNardo CD, Aviv A, Ma F, De Oliveira MM, de Azambuja AP, Dunbar CE, Olszewska M, Olivier E, Papapetrou EP, Giri N, Alter BP, Bonfim C, Wu CO, Garcia-Manero G, Savage SA, Young NS, Colla S, Calado RT. Clonal landscape and clinical outcomes of telomere biology disorders: somatic rescue and cancer mutations. Blood. 2024 Dec 5;144(23):2402-2416. doi: 10.1182/blood.2024025023. PMID: 39316766.

